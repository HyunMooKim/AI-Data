# -*- coding: utf-8 -*-
"""Q4.py

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1bHvWDTA1Pn7_f2jMJ0uD5cpK4nsSQA3c
"""

#알고리즘 과제4
#huffman code
'''
 각 문자의 빈도수를 확인해 
 가장 많은 빈도수를 갖는 문자에게 가작 적은 비트수를 할당하는
 HUFFMAN CODE
'''
#빈도수, 왼쪽 노드, 오른쪽노드, 문자를 갖는 node
class node:
    def __init__(self,freq):
      self.freq = freq
      self.code = ''
      self.left = ''
      self.right = ''
      self.char = ''
    def setchar(self, char):
      self.char = char
    def setleft(self, left):
      self.left = left
    def setright(self,right):
      self.right = right

#heapsize와 node의 리스트를 갖는 queue
#heapsize는 노드개수다. index아님에 주의
class queue:
  ary= list()
  def __init__(self,heapsize):  
    self.heapsize = heapsize
    for i in range(0,heapsize):
      temp = node(0)
      self.ary.append(temp)

def min_heapify(queue,i):
  l = 2*i
  r = 2*i +1
  if(l <= queue.heapsize-1 and queue.ary[l].freq < queue.ary[i].freq ):
    minimum =  l
  else:
    minimum = i
  if(r <= queue.heapsize-1 and queue.ary[r].freq < queue.ary[minimum].freq):
    minimum = r
  if(minimum != i):
    queue.ary[i],queue.ary[minimum] =queue.ary[minimum],queue.ary[i]
    min_heapify(queue,minimum)

def build_min_heap(queue):
  j= (queue.heapsize -1) // 2  
  for i in range(j, -1, -1): #0까지 하려면 -1로 설정
    min_heapify(queue,i)

def extract_min(queue):
  if (queue.heapsize < 1):
    print("error_underflow")
    return -1
  max = queue.ary[0]
  queue.ary[0] = queue.ary[queue.heapsize -1]
  queue.heapsize = queue.heapsize -1
  min_heapify(queue,0)
  return max

def heap_increase_key(queue,i,key):
  if (key.freq < queue.ary[i].freq):
    print("error")
    return -1
  queue.ary[i] = key
  while( i>0 and queue.ary[i//2].freq > queue.ary[i].freq):
    queue.ary[i],queue.ary[i//2] = queue.ary[i//2],queue.ary[i]
    i = i//2

def min_heap_insert(queue,key):
  queue.heapsize =queue.heapsize +1
  queue.ary[queue.heapsize-1] = node(-float("inf"))
  heap_increase_key(queue,queue.heapsize-1,key)

def huffman(queue):
  num = queue.heapsize
  Huff = queue
  for i in range(1,n):
    x = extract_min(Huff)
    y = extract_min(Huff)
    z = node(x.freq + y.freq)
    z.setleft(x)
    z.setright(y)
    min_heap_insert(queue,z)
    '''
    for x in range(0,queue.heapsize):
      print(queue.ary[x].freq)
    print()
    '''
  return extract_min(queue)

def result_huffman(root):
  if (root.left != ''): #leaf가 아니라면
    left = root.left 
    left.code = root.code +'0'
    result_huffman(left)
    right = root.right
    right.code = root.code +'1'
    result_huffman(right)
  else:
    result.append(root)



#총 문자개수n 과 각 빈도수를 받는다
inputlist = list()
result = list()
n = int(input())
Q = queue(n)

for i in range(0,n):
  temp = int(input())
  inputlist.append(temp)
  Q.ary[i] = node(inputlist[i])

build_min_heap(Q) #minheap으로 만들기
root = huffman(Q) #huffman tree만들어서 루트노드 반환

result_huffman(root)

for i in range(0,n):
  for j in range(0,n):
    if(inputlist[i] == result[j].freq):
      print(result[j].code)