# -*- coding: utf-8 -*-
"""Q4.py

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1bHvWDTA1Pn7_f2jMJ0uD5cpK4nsSQA3c
"""

#Dijkstra

'''
input
Line 0: names of vertices, separated by comma  ex) A,B,C,D,E,F,G (sorted alphabetically)
Line 1: the number of edges n
Line 2~(n+1): one edge per line, edge = (vertex_from,vertex_to,weight)

output
Line 0: shortest path distance from A to A
Line 1: shortest path distance from A to B
Line 2: shortest path distance from A to C
...

sample1:
A,B,C,D,E
10
A,B,10
A,C,5
B,C,2
B,D,1
C,B,3
C,D,9
C,E,2
D,E,4
E,A,7
E,D,6


0
8
5
9
7


sample 2
A,B,C,D,E
8
A,B,2
A,D,4
B,C,1
B,D,1
C,B,2
D,E,3
E,B,3
E,C,6

0
2
3
3
6


sample3
A,B,C,D,E,F
9
A,B,8
A,C,1
A,D,2
C,B,5
C,D,2
D,E,3
D,F,5
E,F,1
F,A,5

0
6
1
2
5
6
'''

class vertex:
    def __init__(self, distance =0):
      self.distance = distance
    def setchar(self,char):
      self.char = char
    def setdistance(self, distance):
      self.distance = distance

class queue:
  ary= list()
  def __init__(self,heapsize):  
    self.heapsize = heapsize
    for i in range(0,heapsize):
      temp = vertex()
      self.ary.append(temp)

def min_heapify(queue,i):
  l = 2*i
  r = 2*i +1
  if(l <= queue.heapsize-1 and queue.ary[l].distance < queue.ary[i].distance ):
    minimum =  l
  else:
    minimum = i
  if(r <= queue.heapsize-1 and queue.ary[r].distance < queue.ary[minimum].distance):
    minimum = r
  if(minimum != i):
    queue.ary[i],queue.ary[minimum] =queue.ary[minimum],queue.ary[i]
    min_heapify(queue,minimum)

def build_min_heap(queue):
  j= (queue.heapsize -1) // 2  
  for i in range(j, -1, -1): 
    min_heapify(queue,i)

def extract_min(queue):
  if (queue.heapsize < 1):
    print("error_underflow")
    return -1
  min = queue.ary[0]
  queue.ary[0] = queue.ary[queue.heapsize -1]
  queue.heapsize = queue.heapsize -1
  min_heapify(queue,0)
  return min

#다익스트라에 필요한건, i번째 가 아니다! 힙이 계속 바뀌니까!
def heap_decrease_key(queue,v, key):
  for i in range(0, vn):
    if( queue.ary[i].char == chr(v+65)):
      index = i

  queue.ary[index].distance = key
  while( index>0 and queue.ary[index//2].distance > queue.ary[index].distance):
    queue.ary[index],queue.ary[index//2] = queue.ary[index//2],queue.ary[index]
    index = index//2

#queue와, i번째(이건 build heap 단계에서 마지막 노드의 부모부터 넣어준다) , 그리고 node(vertex)역할을 파라미터로한다.
def heap_increase_key(queue,i,key):
  if (key.freq < queue.ary[i].freq):
    print("error")
    return -1
  queue.ary[i] = key
  while( i>0 and queue.ary[i//2].freq > queue.ary[i].freq):
    queue.ary[i],queue.ary[i//2] = queue.ary[i//2],queue.ary[i]
    i = i//2

def min_heap_insert(queue,key):
  queue.heapsize =queue.heapsize +1
  queue.ary[queue.heapsize-1] = vertex()
  queue.ary[queue.heapsize-1].distance = -float("inf")
  heap_increase_key(queue,queue.heapsize-1,key)

#입력 1  - 모든 vertex 생성
vertexes = input() 
vertexes = vertexes.split(',')
vn = len(vertexes)
##create heap
Q= queue(vn)
Q.ary[0].distance = 0
ascii = ord('A')
Q.ary[0].char = chr(ascii)
for i in range(1, vn):
  Q.ary[i].distance = float("inf")
  ascii = ascii + 1
  Q.ary[i].char = chr(ascii)

#입력2 - number of edge
n = int(input())

#입력3 - edge array
E = [[0 for col in range(n)] for row in range(n)]
for i in range(0,vn):
  for j in range(0,vn):
    E[i][j] = float("inf")
for i in range(0,n):
  edgeinput = input()
  edgeinput = edgeinput.split(',')
  raw = ord(edgeinput[0]) - ord('A')
  col = ord(edgeinput[1]) - ord('A')
  E[raw][col] = int(edgeinput[2])

#DIJKSTRA
result = [float("inf") for i in range(vn)]
result[0]= 0
while ( Q.heapsize != 0):
  u_vertex = extract_min(Q)
  u = ord(u_vertex.char) - 65
  result[u] = u_vertex.distance
  for v in range(0,vn):
    if(E[u][v] != float("inf")):
      if(result[v] > result[u] + E[u][v]):
        result[v] = result[u] + E[u][v]
        heap_decrease_key( Q ,v, result[v])
for i in range(0, vn):
  print(result[i])